python run_cpp_backend.py "#define _XOPEN_SOURCE 500\n\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#include <assert.h>\n\nstruct avl_node_s\n{\n    struct avl_node_s *left;\n    struct avl_node_s *right;\n    int value;\n};\n\ntypedef struct avl_node_s avl_node_t;\n\nstruct avl_tree_s\n{\n    struct avl_node_s *root;\n};\n\ntypedef struct avl_tree_s avl_tree_t;\n\n/* Create a new AVL tree. */\navl_tree_t *avl_create()\n{\n    avl_tree_t *tree = NULL;\n\n    if ((tree = malloc(sizeof(avl_tree_t))) == NULL)\n    {\n        return NULL;\n    }\n\n    tree->root = NULL;\n\n    return tree;\n}\n\n/* Initialize a new node. */\navl_node_t *avl_create_node()\n{\n    avl_node_t *node = NULL;\n\n    if ((node = malloc(sizeof(avl_node_t))) == NULL)\n    {\n        return NULL;\n    }\n\n    node->left = NULL;\n    node->right = NULL;\n    node->value = 0;\n\n    return node;\n}\n\n/* Find the height of an AVL node recursively */\nint avl_node_height(avl_node_t *node)\n{\n    int height_left = 0;\n    int height_right = 0;\n\n    if (node->left)\n        height_left = avl_node_height(node->left);\n    if (node->right)\n        height_right = avl_node_height(node->right);\n\n    return height_right > height_left ? ++height_right : ++height_left;\n}\n\n/* Find the balance of an AVL node */\nint avl_balance_factor(avl_node_t *node)\n{\n    int bf = 0;\n\n    if (node->left)\n        bf += avl_node_height(node->left);\n    if (node->right)\n        bf -= avl_node_height(node->right);\n\n    return bf;\n}\n\n/* Left Left Rotate */\navl_node_t *avl_rotate_leftleft(avl_node_t *node)\n{\n    avl_node_t *a = node;\n    avl_node_t *b = a->left;\n\n    a->left = b->right;\n    b->right = a;\n\n    return (b);\n}\n\n/* Left Right Rotate */\navl_node_t *avl_rotate_leftright(avl_node_t *node)\n{\n    avl_node_t *a = node;\n    avl_node_t *b = a->left;\n    avl_node_t *c = b->right;\n\n    a->left = c->right;\n    b->right = c->left;\n    c->left = b;\n    c->right = a;\n\n    return (c);\n}\n\n/* Right Left Rotate */\navl_node_t *avl_rotate_rightleft(avl_node_t *node)\n{\n    avl_node_t *a = node;\n    avl_node_t *b = a->right;\n    avl_node_t *c = b->left;\n\n    a->right = c->left;\n    b->left = c->right;\n    c->right = b;\n    c->left = a;\n\n    return (c);\n}\n\n/* Right Right Rotate */\navl_node_t *avl_rotate_rightright(avl_node_t *node)\n{\n    avl_node_t *a = node;\n    avl_node_t *b = a->right;\n\n    a->right = b->left;\n    b->left = a;\n\n    return (b);\n}\n\n/* Balance a given node */\navl_node_t *avl_balance_node(avl_node_t *node)\n{\n    avl_node_t *newroot = NULL;\n\n    /* Balance our children, if they exist. */\n    if (node->left)\n        node->left = avl_balance_node(node->left);\n    if (node->right)\n        node->right = avl_balance_node(node->right);\n\n    int bf = avl_balance_factor(node);\n\n    if (bf >= 2)\n    {\n        /* Left Heavy */\n\n        if (avl_balance_factor(node->left) <= -1)\n            newroot = avl_rotate_leftright(node);\n        else\n            newroot = avl_rotate_leftleft(node);\n    }\n    else if (bf <= -2)\n    {\n        /* Right Heavy */\n\n        if (avl_balance_factor(node->right) >= 1)\n            newroot = avl_rotate_rightleft(node);\n        else\n            newroot = avl_rotate_rightright(node);\n    }\n    else\n    {\n        /* This node is balanced -- no change. */\n\n        newroot = node;\n    }\n\n    return (newroot);\n}\n\n/* Balance a given tree */\nvoid avl_balance(avl_tree_t *tree)\n{\n\n    avl_node_t *newroot = NULL;\n\n    newroot = avl_balance_node(tree->root);\n\n    if (newroot != tree->root)\n    {\n        tree->root = newroot;\n    }\n}\n\n/* Insert a new node. */\nvoid avl_insert(avl_tree_t *tree, int value)\n{\n    avl_node_t *node = NULL;\n    avl_node_t *next = NULL;\n    avl_node_t *last = NULL;\n\n    /* Well, there must be a first case */\n    if (tree->root == NULL)\n    {\n        node = avl_create_node();\n        node->value = value;\n\n        tree->root = node;\n\n        /* Okay.  We have a root already.  Where do we put this? */\n    }\n    else\n    {\n        next = tree->root;\n\n        while (next != NULL)\n        {\n            last = next;\n\n            if (value < next->value)\n            {\n                next = next->left;\n            }\n            else if (value > next->value)\n            {\n                next = next->right;\n\n                /* Have we already inserted this node? */\n            }\n            else if (value == next->value)\n            {\n                /* This shouldn\'t happen. */\n            }\n        }\n\n        node = avl_create_node();\n        node->value = value;\n\n        if (value < last->value)\n            last->left = node;\n        if (value > last->value)\n            last->right = node;\n    }\n\n    avl_balance(tree);\n}\n\n/* Find the node containing a given value */\navl_node_t *avl_find(avl_tree_t *tree, int value)\n{\n    avl_node_t *current = tree->root;\n\n    while (current && current->value != value)\n    {\n        if (value > current->value)\n            current = current->right;\n        else\n            current = current->left;\n    }\n\n    return current;\n}\n\n/* Do a depth first traverse of a node. */\nvoid avl_traverse_node_dfs(avl_node_t *node, int depth)\n{\n    int i = 0;\n\n    if (node->left)\n        avl_traverse_node_dfs(node->left, depth + 2);\n\n    for (i = 0; i < depth; i++)\n        putchar(\' \');\n    printf("%d: %d\\n", node->value, avl_balance_factor(node));\n\n    if (node->right)\n        avl_traverse_node_dfs(node->right, depth + 2);\n}\n\n/* Do a depth first traverse of a tree. */\nvoid avl_traverse_dfs(avl_tree_t *tree)\n{\n    avl_traverse_node_dfs(tree->root, 0);\n}\n\nint main(int argc, char **argv)\n{\n    avl_tree_t *tree = NULL;\n    int i = 0;\n    int r = 0;\n\n    tree = avl_create();\n\n    /* Insert 1-20 in random order -- this is suboptimal, but easy */\n    srand(time(NULL));\n\n    for (i = 0; i < 20; i++)\n    {\n        do\n        {\n            r = rand() % 20 + 1;\n        } while (avl_find(tree, r));\n\n        avl_insert(tree, r);\n    }\n\n    avl_traverse_dfs(tree);\n\n    return 0;\n}" c